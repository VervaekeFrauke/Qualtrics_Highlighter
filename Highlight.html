<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Qualtrics Highlighter</title>

<style>
body { font-family: sans-serif; padding: 20px; }
#stimulus { border: 1px solid #ccc; padding: 15px; border-radius: 5px; }
.highlighted { background-color: yellow; cursor: pointer; }
</style>
</head>
<body>

<div id="stimulus">
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
</div>

<script>
const stimDiv = document.getElementById("stimulus");
let rawText = stimDiv.textContent;
let highlights = [];  
// each item: {start: Number, end: Number, text: String}

// ---- Re-render text with highlights applied ----
function render() {
    let html = "";
    let last = 0;

    // Sort by start index
    highlights.sort((a, b) => a.start - b.start);

    for (let h of highlights) {
        html += rawText.slice(last, h.start);  
        html += `<span class="highlighted" data-start="${h.start}" data-end="${h.end}">${rawText.slice(h.start, h.end)}</span>`;
        last = h.end;
    }
    html += rawText.slice(last);

    stimDiv.innerHTML = html;

    // Add click-to-remove
    stimDiv.querySelectorAll(".highlighted").forEach(span => {
        span.onclick = () => {
            const s = Number(span.dataset.start);
            const e = Number(span.dataset.end);
            highlights = highlights.filter(h => !(h.start === s && h.end === e));
            render();
        };
    });
}

// ---- Detect selection and add to highlights ----
stimDiv.addEventListener("mouseup", () => {
    const sel = window.getSelection();
    const text = sel.toString();

    if (!text.trim()) return;

    let anchorNode = sel.anchorNode;
    let focusNode = sel.focusNode;
    if (!anchorNode || !focusNode) return;

    // Compute absolute start & end indexes in rawText
    const full = rawText;
    const selection = sel.getRangeAt(0);

    const range = selection;
    const preRange = range.cloneRange();
    preRange.selectNodeContents(stimDiv);

    preRange.setEnd(range.startContainer, range.startOffset);
    let start = preRange.toString().length;
    let end = start + text.length;

    // Prevent duplicate identical ranges
    if (!highlights.some(h => h.start === start && h.end === end)) {
        highlights.push({ start, end, text });
        render();
    }

    sel.removeAllRanges();
});

// ---- Export highlights to Qualtrics before Next button ----
function sendToQualtrics() {
    window.parent.Qualtrics.SurveyEngine.setEmbeddedData("highlight_count", highlights.length);

    highlights.forEach((h, i) => {
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_text`, h.text);
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_start`, h.start);
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_end`, h.end);
    });
}

// ---- Receive signal from Qualtrics Next button ----
window.addEventListener("message", e => {
    if (e.data === "qualtricsNext") sendToQualtrics();
});
</script>

</body>
</html>
