<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Qualtrics Highlighter - Robust</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 16px; }
  #stimulus {
    border: 1px solid #ccc;
    padding: 12px;
    border-radius: 6px;
    white-space: pre-wrap;      /* preserve spaces/newlines exactly like in the source text */
    line-height: 1.4;
    user-select: text;
  }
  .highlighted {
    background: #ffeb3b;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="stimulus">
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
</div>

<script>
(function() {
  const stimDiv = document.getElementById('stimulus');

  // rawText is the authoritative plain-text copy of the stimulus
  const rawText = stimDiv.textContent;
  let highlights = []; // {start: Number, end: Number, text: String}

  // Render DOM from rawText + highlights using createTextNode + span nodes.
  function render() {
    // sort highlights by start
    highlights.sort((a,b) => a.start - b.start);

    // create document fragment to avoid innerHTML string replace issues
    const frag = document.createDocumentFragment();
    let last = 0;
    for (const h of highlights) {
      // append text from last to highlight.start
      if (h.start > last) {
        frag.appendChild(document.createTextNode(rawText.slice(last, h.start)));
      }
      // create highlighted span for exact range
      const span = document.createElement('span');
      span.className = 'highlighted';
      span.dataset.start = h.start;
      span.dataset.end = h.end;
      span.textContent = rawText.slice(h.start, h.end);
      frag.appendChild(span);
      last = h.end;
    }
    // append remaining text
    if (last < rawText.length) {
      frag.appendChild(document.createTextNode(rawText.slice(last)));
    }

    // replace content (safe because we used nodes, not parsed HTML strings)
    stimDiv.innerHTML = '';
    stimDiv.appendChild(frag);

    // attach click-to-remove handlers to spans
    stimDiv.querySelectorAll('.highlighted').forEach(span => {
      span.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const s = Number(span.dataset.start);
        const e = Number(span.dataset.end);
        highlights = highlights.filter(h => !(h.start === s && h.end === e));
        render();
      });
    });
  }

  // compute absolute start index of selection relative to rawText
  function getSelectionOffsets() {
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    const range = sel.getRangeAt(0);
    const text = range.toString();
    if (!text.trim() && text.length === 0) return null;

    // Create a clone range that starts at the beginning of the stimDiv and ends at selection start
    const preRange = document.createRange();
    preRange.selectNodeContents(stimDiv);
    preRange.setEnd(range.startContainer, range.startOffset);
    const start = preRange.toString().length;
    const end = start + text.length;

    return { start, end, text };
  }

  // Add highlight if it doesn't overlap exactly the same range
  function addHighlightFromSelection() {
    const info = getSelectionOffsets();
    if (!info) return;
    // avoid duplicates (same start & end)
    if (highlights.some(h => h.start === info.start && h.end === info.end)) {
      window.getSelection().removeAllRanges();
      return;
    }
    // Prevent highlights outside rawText bounds
    if (info.start < 0 || info.end > rawText.length || info.start >= info.end) {
      window.getSelection().removeAllRanges();
      return;
    }
    highlights.push({ start: info.start, end: info.end, text: info.text });
    render();
    window.getSelection().removeAllRanges();
  }

  // Hook selection end
  stimDiv.addEventListener('mouseup', function(e) {
    // Use a short timeout because some browsers finalize selection slightly after mouseup
    setTimeout(addHighlightFromSelection, 0);
  });

  // Also support double-click (word selection), keyboard selection, etc.
  stimDiv.addEventListener('keyup', function(e) {
    if (e.key === 'Enter' || e.key === ' ' || e.key === 'Escape') return;
    setTimeout(addHighlightFromSelection, 0);
  });

  // Send highlights to Qualtrics when told (postMessage)
  function sendToQualtrics() {
    try {
      // set highlight_count
      window.parent.Qualtrics.SurveyEngine.setEmbeddedData('highlight_count', highlights.length);
      // set per-highlight fields
      highlights.forEach((h, i) => {
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_text`, h.text);
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_start`, h.start);
        window.parent.Qualtrics.SurveyEngine.setEmbeddedData(`highlight_${i+1}_end`, h.end);
      });
      // clear any unused reason_N fields? Qualtrics will leave them blank if not set.
    } catch (err) {
      console.warn('Could not set embedded data (are you testing locally without Qualtrics parent?)', err);
    }
  }

  window.addEventListener('message', function(e) {
    if (e.data === 'qualtricsNext') {
      sendToQualtrics();
    }
  });

  // initial render
  render();

  // Expose for debugging in console (optional)
  window.__highlighter_debug = { rawText, highlights, render };
})();
</script>
</body>
</html>
